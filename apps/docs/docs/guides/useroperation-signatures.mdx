---
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# UserOperation signature

Encoding the data to validate a UserOperation.

The ERC-4337 standard is un-opinionated in terms of how the signature field is encoded. **In this guide, we outline what the [Contracts package](/docs/category/contracts) requires from the [`UserOperation`](../introduction/erc-4337-overview.md#useroperation) for validation.**

## The `requestId`

The `requestId` is a hash of three things in order:

1. The entire `UserOperation` (minus the signature field).
2. The `EntryPoint` address.
3. The `chainId`.

**All signatures should be a signed message of the `requestId`.** To optimize gas, the `EntryPoint` will generate this hash once and pass it to both `validateUserOp` and `validatePaymasterUserOp` during the [verification phase](../introduction/erc-4337-overview.md#entrypoint).

:::tip

The [`UserOperationBuilder`](../packages/client-sdk/useroperation.md#useroperationbuilder) exposes a `getRequestId` function on it's middleware context to easily calculate the latest value at any stage of building an operation.

:::

## `EOA` signature types

ECDSA signatures from an `EOA` cannot be aggregated. Hence we encode an object so we can differentiate between the `Wallet` and `Paymaster` signatures when required.

<Tabs>
  <TabItem value="solidity" label="Solidity" default>

Working with `EOASignatureData` on-chain can be done with the following type.

```solidity
import @PackageName/contracts/ERC4337/EOASignatureData.sol;
```

```solidity
struct EOASignatureData {
  bytes wallet;
  bytes paymaster;
}

```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

Encoding `EOASignatureData` off-chain can be done with [ethers.js](https://docs.ethers.io/).

**On the paymaster:**

```typescript
import { ethers } from "ethers";

const types = ["bytes wallet", "bytes paymaster"];

// Paymaster can create the initial signature field
// before returning the UserOperation to the wallet
userOp.signature = ethers.utils.defaultAbiCoder.encode(types, [
  "0x",
  paymasterSignature,
]);
```

**On the wallet:**

```typescript
import { ethers } from "ethers";

const types = ["bytes wallet", "bytes paymaster"];

// Wallet can append it's own signature
// before sending the UserOperation to the client
const paymasterSignature = ethers.utils.defaultAbiCoder.decode(
  types,
  userOp.signature
).paymaster;
userOp.signature = ethers.utils.defaultAbiCoder.encode(types, [
  walletSignature,
  paymasterSignature,
]);
```

  </TabItem>
</Tabs>
